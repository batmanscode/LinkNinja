[
  {
    "objectID": "link_ninja.html",
    "href": "link_ninja.html",
    "title": "Link Ninja",
    "section": "",
    "text": "This has two components: the bot itself, and a database. I’ll start with the database since it’ll have to be defined first to be used by the bot.\nNearly all imports used by functions are imported first (outside the function) since they will be used very frequently."
  },
  {
    "objectID": "link_ninja.html#what-data-will-be-stored",
    "href": "link_ninja.html#what-data-will-be-stored",
    "title": "Link Ninja",
    "section": "What data will be stored?",
    "text": "What data will be stored?\n\nDates are UTC in the format dd-mm-yyyy hh:00, in code this is %d-%m-%Y %H:00 (see Python strftime cheatsheet for more formats).\nkey is required and needs to be unique; keys are automatically generated by Deta if not provided.\nchat_id is a unique value given by Telegram and will be used as the key in settings since each chat_id needs to be entered only once.\nULIDs (Universally Unique Lexicographically Sortable Identifiers) are used as keys everywhere else and order is is preserved here since data in Bases are ordered by key. \n\nsettings\nBot settings for each chat\n[{'key': '1111',\n  'signature': False,\n  'twitter': 'fxtwitter.com'}]\n\ntotal-users\nEveryone who pressed /start in a private chat with our bot\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'private chat id': 1111,\n  'user id': 1111}]\n\ncurrent-users\ntotal-users minus people who stopped/blocked our bot\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'private chat id': 1111,\n  'user id': 1111}]\n\nmessage-stats\nCount of how many links were replaced\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'chat id': 1111,\n  'links replaced': 69}]\n\ntotal-groups\nAll groups our bot was added to\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'group chat id': 2222}]\n\ncurrent-groups\nCurrent groups our bot is in\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'group chat id': 2222}]\n\nadmins\nCurrent list of users added as admins\n[{'date': '02-10-2022 17:00',\n  'key': '01BJQMF54D093DXEAWZ6JYRPAQ',\n  'user id': 1111}]\n\nGet a Project Key from Deta\nTo get started, make an account on or log into deta.sh, create a new project and save your Project Key as an evironment variable PROJECT_KEY.\nSee their docs if you need any help: https://docs.deta.sh/docs/base/about"
  },
  {
    "objectID": "link_ninja.html#functions",
    "href": "link_ninja.html#functions",
    "title": "Link Ninja",
    "section": "Functions",
    "text": "Functions\nHandy functions our bot talk will use to talk to its database.\n\n# Initialize with a Project Key\ndeta = Deta(os.environ[\"PROJECT_KEY\"])\n\n\nSettings\nFor this the key in our database will have to be unique so we’ll be using chat IDs\n\ndef update_setting_signature(chat_id, signature = True):\n    \"\"\"\n    create or update setting: signature\n    \"\"\"\n\n    # connect to or create database.\n    db = deta.Base(\"settings\")\n\n    # keys have to be unique so it's the chat_id\n    # unix timestamps could've been used as keys but then chat_id will be re-added each time signature is updated\n    # since the items are fetched by chat_ids and not keys\n    settings = db.update(\n        {\n            \"signature\": signature\n        },\n        key = str(chat_id)\n    )\n\n    print(f\"signature updated\")\n\n\n\n\nupdate_setting_signature\n\n update_setting_signature (chat_id, signature=True)\n\ncreate or update setting: signature\n\ndef update_setting_domain(chat_id, domain = \"fxtwitter.\"):\n    \"\"\"\n    create or update setting: domain\n    \"\"\"\n\n    db = deta.Base(\"settings\")\n\n    settings = db.update(\n        {\n            \"twitter\": domain\n        },\n        key = str(chat_id)\n    )\n\n    print(f\"twitter domain updated\")\n\n\n\n\nupdate_setting_domain\n\n update_setting_domain (chat_id, domain='fxtwitter.')\n\ncreate or update setting: domain\n\ndef default_settings(chat_id, signature = True, domain = \"fxtwitter.com\"):\n    \"set default settings\"\n\n    db = deta.Base(\"settings\")\n\n    settings = db.put(\n        {\n            \"signature\": signature, \n            \"twitter\": domain,\n            \"key\": str(chat_id)\n        }\n    )\n\n    print(f\"settings set to default: {settings}\")\n\n\n\n\ndefault_settings\n\n default_settings (chat_id, signature=True, domain='fxtwitter.com')\n\nset default settings\n\ndef get_settings(chat_id):\n    \"\"\"\n    get settings for a chat\n\n    usage:\n    `get_settings[\"signature\"]`\n    `get_settings[\"domain\"]`\n    \"\"\"\n\n    db = deta.Base(\"settings\")\n\n    settings = db.fetch({\"key\": str(chat_id)}).items\n\n    if bool(settings):\n        print(\"Settings exist\")\n        return settings[0]\n    else: # if list is empty a record for the user hasn't been created\n        print(\"chat settings doesn't exist; creating new/default settings for this chat\")\n\n        # set default settings - signature: on, domain: fxtwitter\n        default_settings(chat_id=chat_id)\n        settings = db.fetch({\"key\": str(chat_id)}).items\n\n        return settings[0]\n\n\n\n\nget_settings\n\n get_settings (chat_id)\n\nget settings for a chat\nusage: get_settings[\"signature\"] get_settings[\"domain\"]\n\ndef delete_setting(chat_id):\n    \"\"\"\n    deletes a user from a database if they exist in it\n    \"\"\"\n\n    db = deta.Base(\"settings\")\n\n    key = str(chat_id)\n\n    delete = db.get(key)\n\n    # if exists, delete\n    if bool(delete):\n        db.delete(key)\n        print(f\"settings of {chat_id} deleted\")\n    else:\n        print(f\"settings of user {chat_id} don't exist\")\n\n\n\n\ndelete_setting\n\n delete_setting (chat_id)\n\ndeletes a user from a database if they exist in it\n\n\nGeneral\nMakes handling info from the database more convenient\n\ndef fetch_all(database_name):\n    \"\"\"\n    fetches the whole database\n\n    this is from deta's docs: https://docs.deta.sh/docs/base/sdk/#fetch-all-items-1\n    \"\"\"\n\n    db = deta.Base(database_name)\n    \n    res = db.fetch()\n    all_items = res.items\n\n    # fetch until last is 'None'\n    while res.last:\n        res = db.fetch(last=res.last)\n        all_items += res.items   \n\n    return all_items\n\n\n\n\nfetch_all\n\n fetch_all (database_name)\n\nfetches the whole database\nthis is from deta’s docs: https://docs.deta.sh/docs/base/sdk/#fetch-all-items-1\n\ndef database_to_dataframe(database_name):\n    \"\"\"\n    fetches the whole database and converts it to a pandas dataframe\n    \"\"\"\n\n    import pandas as pd\n\n    all_items = fetch_all(database_name=database_name)\n\n    return pd.DataFrame.from_dict(all_items)\n\n\n\n\ndatabase_to_dataframe\n\n database_to_dataframe (database_name)\n\nfetches the whole database and converts it to a pandas dataframe\n\n\nUsers\nUnix timespams will be used as keys so order can be preserved.\n\ndef save_user(chat_id, user_id, database_name):\n    \"\"\"\n    save private chat ids to a database\n\n    \"\"\"\n\n    db = deta.Base(database_name)\n\n    # check if user exists\n    check = db.fetch({\"private chat id\": chat_id, \"user id\": user_id}).items\n\n    if bool(check):\n        print(f\"user already exists in {database_name}\")\n    else:\n        # unix timestamps used as keys\n        user = db.put(\n            {\n                \"private chat id\": chat_id, \n                \"user id\": user_id,\n                \"date\": datetime.now().strftime(\"%d-%m-%Y %H:00\"),\n                \"key\": ulid.new().str\n            }\n                )\n\n        print(f\"added to {database_name}: {user}\")\n\n\n\n\nsave_user\n\n save_user (chat_id, user_id, database_name)\n\nsave private chat ids to a database\n\ndef delete_user(chat_id, user_id, database_name):\n    \"\"\"\n    deletes a user from a database if they exist in it\n    \"\"\"\n\n    db = deta.Base(database_name)\n\n    delete = db.fetch(\n        {\n        \"private chat id\": chat_id,\n        \"user id\": user_id\n        }\n    ).items\n\n    # if exists, delete\n    if bool(delete):\n        key = delete[0][\"key\"]\n        db.delete(key)\n        print(f\"user {user_id} deleted from {database_name}\")\n    else:\n        print(f\"user {user_id} not in {database_name}\")\n\n\n\n\ndelete_user\n\n delete_user (chat_id, user_id, database_name)\n\ndeletes a user from a database if they exist in it\nBlocked users are deleted from current-users. If you want to maintain a separate blocked database, use the commented out code at the end of update_users()\n\ndef update_users(chat_id, user_id, blocked=False):\n    \"\"\"\n    save private chat ids to \"total users\" and \"current users\"\n\n    total users: all users who have started the bot\n    blocked: users who have blocked the bot (NOT done by default)\n    current users:  total users - blocked\n\n    \"\"\"\n\n    if blocked == False:\n        databases = [\"total-users\", \"current-users\"]\n\n        for database in databases:\n            save_user(chat_id=chat_id, user_id=user_id, database_name=database)\n\n    else: # delete blocked user from current-users\n        delete_user(chat_id=chat_id, user_id=user_id, database_name=\"current-users\")\n        delete_setting(chat_id=chat_id)\n\n    # dealing with blocked users with a separate \"blocked\" database\n    # else:\n    #     save_user(chat_id=chat_id, user_id=user_id, database_name=\"blocked\")\n\n    #     # blocked = deta.Base(\"blocked\")\n    #     current = deta.Base(\"current-users\")\n\n    #     # get all items from blocked list\n    #     all_blocked = fetch_all(database_name=\"blocked\")\n        \n    #     # search for blocked users in current users\n    #     remove_from_current = current.fetch(all_blocked).items\n\n    #     # get the keys for items to remove from current\n    #     for item in remove_from_current:\n    #         # and delete\n    #         current.delete(item[\"key\"])\n    #         print(f\"{item['user id']} removed from current users\")\n\n\n\n\nupdate_users\n\n update_users (chat_id, user_id, blocked=False)\n\nsave private chat ids to “total users” and “current users”\ntotal users: all users who have started the bot blocked: users who have blocked the bot (NOT done by default) current users: total users - blocked\n\n\nAdmins\n\ndef save_admin(user_id, database_name):\n    \"\"\"\n    save admin user ids to a database\n\n    \"\"\"\n\n    # connect to or create database.\n    db = deta.Base(database_name)\n\n    # check if user exists\n    check = db.fetch({\"user id\": user_id}).items\n\n    if bool(check):\n        print(f\"user already exists in {database_name}\")\n    else:\n        # unix timestamps used as keys\n        user = db.put(\n            {\n                \"user id\": user_id,\n                \"date\": datetime.now().strftime(\"%d-%m-%Y %H:00\"),\n                \"key\": ulid.new().str\n            }\n                )\n\n        print(f\"added to {database_name}: {user}\")\n\n\n\n\nsave_admin\n\n save_admin (user_id, database_name)\n\nsave admin user ids to a database\n\ndef delete_admin(user_id, database_name):\n    \"\"\"\n    deletes an admin from a database if they exist in it\n    \"\"\"\n\n    db = deta.Base(database_name)\n\n    delete = db.fetch(\n        {\n        \"user id\": user_id\n        }\n    ).items\n\n    # if exists, delete\n    if bool(delete):\n        key = delete[0][\"key\"]\n        db.delete(key)\n        print(f\"admin {user_id} deleted from {database_name}\")\n    else:\n        print(f\"admin {user_id} not in {database_name}\")\n\n\n\n\ndelete_admin\n\n delete_admin (user_id, database_name)\n\ndeletes an admin from a database if they exist in it\n\ndef update_admins(user_id, action=\"add\"):\n    \"add or remove users from the admin database\"\n\n    if action==\"add\":\n        return save_admin(user_id=user_id, database_name=\"admins\")\n\n    elif action==\"remove\":\n        return delete_admin(user_id=user_id, database_name=\"admins\")\n\n    else:\n        print(\"action needs to be either 'add' or 'remove'\")\n\n\n\n\nupdate_admins\n\n update_admins (user_id, action='add')\n\nadd or remove users from the admin database\n\n\nMessages\n\ndef update_message_count(chat_id):\n    \"\"\"\n    save and update messages/links seen\n\n    \"\"\"\n\n    # connect to or create database.\n    db = deta.Base(\"message-stats\")\n\n    # check if todays date exists in records\n    # incremenet message count if yes\n    # chat id used as keys\n    # unix timestamps used as keys\n    check = db.fetch(\n        {\n            \"chat id\": chat_id, \n            \"date\": datetime.now().strftime(\"%d-%m-%Y %H:00\")\n        }\n            ).items\n\n    if bool(check):\n\n        # get key from existing record\n        key = check[0][\"key\"]\n\n     # use the same key to update an existing record\n        messages = db.update(\n            {\n                \"links replaced\": db.util.increment(1)\n            },\n            key = key\n                )\n\n        print(f\"message count updated for chat: {chat_id} at key: {key}\")\n\n    else: # create record\n        messages = db.put(\n            {\n                \"date\": datetime.now().strftime(\"%d-%m-%Y %H:00\"),\n                \"chat id\": chat_id, \n                \"links replaced\": int(1),\n                \"key\": ulid.new().str\n            }\n                )\n\n        print(f\"record created: {messages}\")\n\n\n\n\nupdate_message_count\n\n update_message_count (chat_id)\n\nsave and update messages/links seen\n\n\nGroup\nSimilar functions to Users but for groups.\n\ndef save_group(chat_id, database_name):\n    \"\"\"\n    save group chat ids to a database\n\n    \"\"\"\n\n    # connect to or create database.\n    db = deta.Base(database_name)\n\n    # check if user exists\n    check = db.fetch({\"group chat id\": chat_id}).items\n\n    if bool(check):\n        print(f\"user already exists in {database_name}\")\n    else:\n        # unix timestamps used as keys\n        group = db.put(\n            {\n                \"group chat id\": chat_id,\n                \"date\": datetime.now().strftime(\"%d-%m-%Y %H:00\"),\n                \"key\": ulid.new().str\n            }\n                )\n\n        print(f\"added to {database_name}: {group}\")\n\n\n\n\nsave_group\n\n save_group (chat_id, database_name)\n\nsave group chat ids to a database\n\ndef delete_group(chat_id, database_name):\n    \"\"\"\n    deletes a group from a database if it exists in it\n    \"\"\"\n\n    db = deta.Base(database_name)\n\n    delete = db.fetch(\n        {\n        \"group chat id\": chat_id\n        }\n    ).items\n\n    # if exists, delete\n    if bool(delete):\n        key = delete[0][\"key\"]\n        db.delete(key)\n        print(f\"group {chat_id} deleted from {database_name}\")\n    else:\n        print(f\"group {chat_id} not in {database_name}\")\n\n\n\n\ndelete_group\n\n delete_group (chat_id, database_name)\n\ndeletes a group from a database if it exists in it\n\ndef update_groups(chat_id, removed=False):\n    \"\"\"\n    save group chat ids to \"total groups\" and \"current groups\"\n\n    total groups: all users who have started the bot\n    current groups:  total users - blocked\n\n    \"\"\"\n\n    if removed == False:\n        databases = [\"total-groups\", \"current-groups\"]\n\n        for database in databases:\n            save_group(chat_id=chat_id, database_name=database)\n\n    else: # delete blocked user from current-groups\n        delete_group(chat_id=chat_id, database_name=\"current-groups\")\n        delete_setting(chat_id=chat_id)\n\n\n\n\nupdate_groups\n\n update_groups (chat_id, removed=False)\n\nsave group chat ids to “total groups” and “current groups”\ntotal groups: all users who have started the bot current groups: total users - blocked\n\n\nStatistics\n\ndef get_message_count(chat_id):\n    \"\"\"\n    gets stats (number of links replaced) for a given chat id\n\n    \"\"\"\n\n    import pandas as pd\n\n    # connect to or create database.\n    db = deta.Base(\"message-stats\")\n\n    # get data for a sepcific chat id\n    data = db.fetch(\n        {\n            \"chat id\": chat_id\n            }\n            ).items\n\n    # load into pandas and group by the chat id column\n    df = pd.DataFrame.from_dict(data)\n\n    try:\n        df = df.groupby('chat id', as_index=False).sum()\n        messages = df['links replaced'][0]\n    except: # if there's 0 messages for the chat\n        messages = 0    \n\n    return messages\n\n\n\n\nget_message_count\n\n get_message_count (chat_id)\n\ngets stats (number of links replaced) for a given chat id\n\ndef all_stats():\n    \"\"\"\n    get stats on number of users, chats and messages\n\n    it returns five variables: users, groups, messages, total_users, total_groups\n\n    \"\"\"\n\n    users = database_to_dataframe(\"current-users\")\\\n            [\"private chat id\"].count()\n\n    try:\n        groups = database_to_dataframe(\"current-groups\")\\\n                [\"group chat id\"].count()\n    except:\n        groups = 0\n\n    messages = database_to_dataframe(\"message-stats\")\\\n            [\"links replaced\"].sum()\n\n    total_users = database_to_dataframe(\"total-users\")\\\n            [\"private chat id\"].count()\n\n    total_groups = database_to_dataframe(\"total-groups\")\\\n            [\"group chat id\"].count()\n\n    return users, groups, messages, total_users, total_groups\n\n\n\n\nall_stats\n\n all_stats ()\n\nget stats on number of users, chats and messages\nit returns five variables: users, groups, messages, total_users, total_groups\n\ndef admin_stats():\n    \"\"\"\n    shows number of admins\n\n    \"\"\"\n\n    admins = database_to_dataframe(\"admins\")\\\n            [\"user id\"].count()\n\n    return admins\n\n\n\n\nadmin_stats\n\n admin_stats ()\n\nshows number of admins"
  },
  {
    "objectID": "link_ninja.html#the-bot",
    "href": "link_ninja.html#the-bot",
    "title": "Link Ninja",
    "section": "The bot",
    "text": "The bot\nOur bot will do something when it sees a command like /start or notices a link that needs to be sneakily [or not so sneakily] replaced\n\nBuilt using https://github.com/eternnoir/pyTelegramBotAPI\n\n\nCreate a Telegram bot\nChat with https://t.me/BotFather to create a new Telegram bot and save the API token as an environment variable BOT_TOKEN.\nInstantiate our bot! 🤖\n\nbot = telebot.TeleBot(os.environ[\"BOT_TOKEN\"])\n\n\n\n/start\n\nSends a welcome message; only avilable in a private chat.\nUpdates our database:\n\nCreates a new user entry in total-users and current-users if it doesn’t exist.\nDefault: if someone is restarting our bot after blocking, they’ll be added back to current-users.\nOptional: blocked is updated if our bot is restarted. See the commented out delete_user().\n\n\n\n@bot.message_handler(commands=['start'], chat_types=['private'])\ndef send_welcome(message):\n    \"send a message when `/start` is sent in a private chat\"\n\n    # delete_user(chat_id=message.chat.id, user_id=message.from_user.id, database=\"blocked\") # use only for having a separate \"blocked\" database\n    update_users(chat_id=message.chat.id, user_id=message.from_user.id, blocked=False)\n    default_settings(chat_id=message.chat.id, signature=False)\n\n    text=\"Welcome to Link Ninja! \\n\\n\" \\\n    \"This bot will replace all Twitter links with fxtwitter.com by default. \\n\" \\\n    \"You can change this to nitter.net or a custom domain. \\n\\n\" \\\n    \"Use /help to see how it works.\"\n\n    bot.reply_to(message, text)\n\n\n\n\nsend_welcome\n\n send_welcome (message)\n\nsend a message when /start is sent in a private chat\n\n\nSettings\n\nSignature /signature on or off to show the original link along with who sent it\nDomain /domain {domain.tld} to change the domain from the default fxtwitter.com\n\nA message with a defined /{command} will be heard by our bot. To know what settings to change, our bot will accept messages in the format /{setting name} {setting update}.\nFor example /signature on or /domain nitter.net.\nThe setting will be parsed from the message like this:\n\nmessage = \"/signature on\"\n\nWhitespace is removed first\n\nmessage.replace(\" \", \"\")\n\n'/signatureon'\n\n\nThen split at the command\n\nmessage.replace(\" \", \"\").split('/signature')\n\n['', 'on']\n\n\nAnd finally, the setting itself is selected\n\nmessage.replace(\" \", \"\").split('/signature')[1]\n\n'on'\n\n\nOnly admins should be able to change settings in a group chat, so lets make a function for that.\nIt will return True if the user is an admin, owner or it’s a private chat.\n\ndef is_admin(chat_id, user_id):\n    \"\"\"\n    check whether a user is an admin\n    \n    works in both private and groups chats\n    \"\"\"\n\n    if bot.get_chat_member(chat_id, user_id).status in ['creator', 'administrator']:\n        admin = True\n    else:\n        admin = False\n\n    if bot.get_chat(chat_id).type == \"private\" or admin == True:\n        return True\n    else:\n        return False\n\n\n\n\nis_admin\n\n is_admin (chat_id, user_id)\n\ncheck whether a user is an admin\nworks in both private and groups chats\n\n@bot.message_handler(commands=['signature'])\ndef signature_setting(message):\n    \"changes `/signature` setting\"\n\n    if is_admin(chat_id=message.chat.id, user_id=message.from_user.id):\n\n        signature = message.text.replace(\" \", \"\").split('/signature')[1]\n\n        if signature == 'on':\n            update_setting_signature(chat_id=message.chat.id, signature=True)\n            bot.reply_to(message, \"Signatures turned on\")\n        elif signature == 'off':\n            update_setting_signature(chat_id=message.chat.id, signature=False)\n            bot.reply_to(message, \"Signatures turned off\")\n        else:\n            bot.reply_to(message, 'Use \"/signature on\" or \"/signature off\"')\n\n    else:\n        bot.reply_to(message, \"Beg your superior admin to change this setting\")\n\n\n\n\nsignature_setting\n\n signature_setting (message)\n\nchanges /signature setting\n\n@bot.message_handler(commands=['domain'])\ndef domain_setting(message):\n    \"changes `/domain` setting\"\n\n    if is_admin(chat_id=message.chat.id, user_id=message.from_user.id):\n\n        custom_domain = message.text.replace(\" \", \"\").split('/domain')[1]\n\n        if custom_domain == 'reset':\n            update_setting_domain(chat_id=message.chat.id, domain=\"fxtwitter.com\")\n            bot.reply_to(message, \"Reset to fxtwitter.com\")\n        elif validators.domain(custom_domain):\n            update_setting_domain(chat_id=message.chat.id, domain=custom_domain)\n            bot.reply_to(message, f\"Custom domain set to {custom_domain}\")\n        else:\n            bot.reply_to(message, 'Use the format \"/domain nitter.net\" or reset with \"/domain reset\"')\n\n    else:\n        bot.reply_to(message, \"Beg your superior admin to change this setting\")\n\n\n\n\ndomain_setting\n\n domain_setting (message)\n\nchanges /domain setting\n\n\nReplacing twitter links\nWhat will this do? - Detect twitter links - Send a new message with the domain replaced - New message will have the original link and sender name (default, can be turned off) - Deletes the original message that had the link \nHow will it find links? - Regex \nCriteria: - Any twitter link that isn’t a profile - Messages that only contain links i.e. no whitespace\n\nParsing links from messages\nDone with urlparse which is part of python. Here’s an example:\n\nfrom urllib.parse import urlparse\n\n\nurl = 'https://twitter.com/MKBHD/status/1569801859325431808?s=19'\n\nparse = urlparse(url)\n\nf\"{parse.scheme}://fx{parse.netloc}{parse.path}\"\n\n'https://fxtwitter.com/MKBHD/status/1569801859325431808'\n\n\nHere’s a function that will replace the domain with the one specified in our settings databse:\n\ndef replace_link(text, chat_id):\n    \"check chat settings and replace the domain in URLs\"\n\n    from urllib.parse import urlparse\n\n    parse = urlparse(text)\n\n    custom_domain = get_settings(chat_id)[\"twitter\"]\n\n    return f\"{parse.scheme}://{custom_domain}{parse.path}\"\n\n\n\n\n\nreplace_link\n\n replace_link (text, chat_id)\n\ncheck chat settings and replace the domain in URLs\n\nFinding messages Twitter links\n\nMaking the regular expresion:\n\nGet twitter links\n\n\nRegex to validate a twitter url modified to get only links to tweets instead of profiles.\nDone by selecting for https://twitter.com/{profile}/status.\n\n\nGet messages that only have links\n\n\nDone by filtering for twitter links + no whitespace\nWhat is the regular expression for matching that contains no white space in between text? modified to get all messages without whitespace.\n\n\nCombine both\n\n\nUsing the pattern /^(?=^abc)(?=.*xyz$)(?=.*123)(?=^(?:(?!456).)*$).*$/ from Combine Regexp? \n\nFinal expression used by our bot:\n\n^(?=.*(http(?:s)?:\\/\\/(?:www)?twitter\\.com\\/([a-zA-Z0-9_]+)\\/([a-zA-Z0-9_]+)))(?=.*(^\\s*\\S+\\s*)$).*$\nAvailable here: https://rubular.com/r/pJRmWeFvKk\n\n\n\n\nPicture title\n\n\n\n@bot.message_handler(regexp=\"^(?=.*(http(?:s)?:\\/\\/(?:www)?twitter\\.com\\/([a-zA-Z0-9_]+)\\/([a-zA-Z0-9_]+)))(?=.*(^\\s*\\S+\\s*)$).*$\")\ndef send_new_link(message):\n    \"\"\"\n    - replaces twitter links with a domain specified in settings using `replace_link()`\n    - sends a new message with the updated link\n    - deletes the original link unless it's a private chat\n    \"\"\"\n\n    # if signature: off\n    if get_settings(chat_id=message.chat.id)[\"signature\"] == False:\n        user = None\n\n    else:\n        # check if username has been set so they can be tagged/mentioned\n        # if no username, mention with first and last name\n        if message.from_user.username is None:\n            # all users will have a first name\n            # check if last name exists\n            if message.from_user.last_name:\n                name = f\"{message.from_user.first_name} {message.from_user.last_name}\"\n            else:\n                name = message.from_user.first_name\n\n            user = f\"&lt;a href='tg://user?id={message.from_user.id}'&gt;{name}&lt;/a&gt;\"\n        \n        # if username exists, use that\n        elif message.from_user.username:\n            user = f\"@{message.from_user.username}\"\n\n        # if it's a channel/group with a username, use that  \n        elif message.sender_chat.username:\n            user = f\"@{message.sender_chat.username}\"\n\n        # or use the channel/group title\n        elif message.sender_chat.title:\n            user = f\"&lt;b&gt;{message.sender_chat.title}&lt;/b&gt;\"\n\n        else:\n            user = None\n\n    # message to send along with the fxtweet/new link\n    ninja_link = replace_link(text=message.text, chat_id=message.chat.id)\n\n    if user is None:\n        text = f\"{ninja_link}\"\n    else:\n        text = f\"{ninja_link}\\n\\n\" \\\n        f\"&lt;a href='{message.text}'&gt;Tweet&lt;/a&gt; sent by {user}\"\n\n    bot.send_message(\n        message.chat.id,\n        parse_mode=\"HTML\",\n        text=text\n        )\n\n\n    # if it's not a private chat, delete the original message/link\n    if message.chat.type != \"private\":\n\n        bot.delete_message(\n            chat_id=message.chat.id,\n            message_id=message.message_id\n        )\n\n    # update message count\n    update_message_count(chat_id=message.chat.id)\n\n\n\n\n\n\nsend_new_link\n\n send_new_link (message)\n\n\nreplaces twitter links with a domain specified in settings using replace_link()\nsends a new message with the updated link\ndeletes the original link unless it’s a private chat\n\n\n\nBot added or removed\n\nWhen our bot is added to a group\nWhat do we do? ~Celebrate! 🥳~ Update our group database.\nWhat about for private chat? That’s done in send_welcome() when someone sends /start to our dear bot 🙂.\n\n\nGot blocked? :(\nThose losers need to get removed (from our database 😇).\n\n@bot.my_chat_member_handler()\ndef added_or_blocked(message: telebot.types.ChatMemberUpdated):\n    \"updates our database when added to a group\"\n\n    new = message.new_chat_member\n\n    if new.status in [\"member\", \"creator\", \"administrator\"]:\n        if message.chat.type == \"group\":\n            update_groups(chat_id=message.chat.id, removed=False)\n            print(f\"added to group: {message.chat.id}\")\n\n    if new.status not in [\"member\", \"creator\", \"administrator\"] or new.status == \"kicked\":\n        if message.chat.type == \"group\":\n            update_groups(chat_id=message.chat.id, removed=True)\n            print(f\"got removed from group: {message.chat.id}\")\n\n        if message.chat.type == \"private\":\n            update_users(chat_id=message.chat.id, user_id=message.from_user.id, blocked=True)\n            print(f\"got blocked in private chat: {message.chat.id}\")\n\n\n\n\n\nadded_or_blocked\n\n added_or_blocked (message:telebot.types.ChatMemberUpdated)\n\nupdates our database when added to a group\n\n\n/stats\nShows count of links replaced in chat chat the command is used.\n\n@bot.message_handler(commands=['stats'])\ndef message_count(message):\n    \"Show message count for the chat this command is used in\"\n\n    stats = get_message_count(chat_id=message.chat.id)\n\n    text=f\"{stats} links replaced by Link Ninja in this chat\"\n\n    bot.reply_to(message, text)\n\n\n\n\nmessage_count\n\n message_count (message)\n\nShow message count for the chat this command is used in\n\n\n/allstats\nShows total count of chats and messages\n\n@bot.message_handler(commands=['allstats'])\ndef signature_setting(message):\n    \"show all bot stats\"\n\n    users, groups, messages, total_users, total_groups = all_stats()\n\n    text=\"&lt;b&gt;Link Ninja stats&lt;/b&gt; \\n\\n\" \\\n    f\"&lt;i&gt;All time&lt;/i&gt; \\n\" \\\n    f\"Links replaced: {messages} \\n\" \\\n    f\"Users: {total_users} \\n\" \\\n    f\"Groups: {total_groups} \\n\\n\" \\\n    f\"&lt;i&gt;Current&lt;/i&gt; \\n\" \\\n    f\"Users: {users} \\n\" \\\n    f\"Groups: {groups} \\n\" \\\n\n    bot.reply_to(message, text, parse_mode=\"HTML\")\n\n\n\n\nsignature_setting\n\n signature_setting (message)\n\nshow all bot stats\n\n\nAdmin commands\nThese commands will only work for pre-approved users. The first user will be you!\nGet your user ID with https://t.me/getmyid_bot and save it as an environment variable YOUR_USER_ID.\n\ndef is_bot_admin(user_id):\n    \"checks if a user is an admin or creator of the bot\"\n\n    try:\n        added_admins = list(database_to_dataframe(\"admins\")[\"user id\"])\n    except:\n        print(\"admin dataframe/database empty\")\n        added_admins = []\n\n    if os.environ[\"YOUR_USER_ID\"] == str(user_id):\n        print(\"creator used an admin command\")\n        return True\n    elif user_id in added_admins:\n        print(f\"{user_id} used an admin command\")\n        return True\n    else:\n        print(\"some rando used an admin command\")\n\n\n\n\nis_bot_admin\n\n is_bot_admin (user_id)\n\nchecks if a user is an admin or creator of the bot\n\n/admin {option}\n\nAvailable options: - send Reply to a message with /admin send to private message all bot update_users. - delete (to do/enhancement - this doesn’t work yet) Reply to the message that was sent to delete it in the private chat of all users. - add Add other admins; forward a message to your private chat with the bot from the user you want to add as admin, then reply tthe forwarded message with /admin add. - remove Remove an admin that was added; works the same as add. - count Shows number of admins. - help Shows avilable commands and what they’re for.\n\n@bot.message_handler(commands=['admin'], chat_types=['private'])\ndef admin(message):\n    \"\"\"\n    handles admin commands in private chat\n\n    avilable options:\n    * send - sends a message to all bot user in private chat\n    * add - add new admin\n    * remove - remove admin\n    * count - show current number of admins \n    * help - show avilable commands and what they're for\n    \"\"\"\n\n    if is_bot_admin(user_id=message.from_user.id):\n\n        admin = message.text.replace(\" \", \"\").split('/admin')[1]\n\n        if admin == 'help':\n            text=\"&lt;b&gt;Link Ninja admin commands&lt;/b&gt; \\n\\n\" \\\n            \"Format: /admin {command} \\n\\n\" \\\n            \"send - reply to a message with this to copy and send to all bot users in private chat \\n\" \\\n            \"add - add new admin \\n\" \\\n            \"remove - remove admin \\n\" \\\n            \"count - show current number of admins \\n\" \\\n            \"help - show avilable commands and what they're for\" \\\n\n            bot.reply_to(message, text, parse_mode=\"HTML\")\n\n        elif admin == 'send':\n            forward_to = database_to_dataframe(\"current-users\")\n\n            for chat_id in forward_to[\"private chat id\"]:\n                bot.copy_message(chat_id=chat_id, from_chat_id=message.chat.id, message_id=message.reply_to_message.message_id)\n            \n            # update_settings(chat_id=message.chat.id, signature=True)\n            bot.reply_to(message, f\"message sent to {len(forward_to['private chat id'])} users\")\n            \n        # elif admin == 'delete':\n        #     forward_to = database_to_dataframe(\"current-users\")\n\n        #     for chat_id in forward_to[\"private chat id\"]:\n        #         # note: this needs the message ID of every message sent which has to be saved to our database when `/admin send` is used\n        #         # it will need to iterate through message IDs\n        #         bot.delete_message(chat_id=chat_id, message_id=message.reply_to_message.message_id)\n\n        #     bot.reply_to(message, f\"message deleted from {len(forward_to['private chat id'])} chats\")\n\n        elif admin == 'add':\n            update_admins(user_id=message.reply_to_message.forward_from.id, action=\"add\")\n            admins = admin_stats()\n            bot.reply_to(message, f\"admin added; there are now {admins+1} admins\")\n\n        elif admin == 'remove':\n            update_admins(user_id=message.reply_to_message.forward_from.id, action=\"remove\")\n            try:\n                admins = admin_stats()\n            except: # if all admins have been removed and dataframe is empty\n                admins = 0\n            bot.reply_to(message, f\"admin removed; there are now {admins+1} admins\")\n\n        elif admin == 'count':\n            try:\n                admins = admin_stats()\n                bot.reply_to(message, f\"there are {admins+1} admins\")\n            except: # if admins doesn't exist yet because no additional admins have been added\n                bot.reply_to(message, \"there's no additional admins\")\n\n        else:\n            bot.reply_to(message, \"Available commands are: send, add, remove, count and help\")\n            bot.send_message(message.chat.id, \"Use `/admin help` to learn more\", parse_mode=\"MarkdownV2\")\n\n    else:\n        bot.reply_to(message, \"Non admins get rekt. Send $1000 for forgiveness\")\n\n\n\n\n\nadmin\n\n admin (message)\n\nhandles admin commands in private chat\navilable options: * send - sends a message to all bot user in private chat * add - add new admin * remove - remove admin * count - show current number of admins * help - show avilable commands and what they’re for\n\n\n/help\nExplans how the bot works and shows the available settings.\n\n@bot.message_handler(commands=['help'], chat_types=['private'])\ndef admin(message):\n    \"\"\"\n    send help message in private chat\n    \"\"\"\n\n    text=\"&lt;b&gt;Link Ninja info&lt;/b&gt; \\n\\n\" \\\n    \"&lt;b&gt;What does it do?&lt;/b&gt; \\n\" \\\n    \"- Replaces twitter.com links with fxtwitter.com. \\n\" \\\n    \"- You can change it to nitter.net or your own nitter domain. \\n\\n\" \\\n    \"&lt;b&gt;How do you use it?&lt;/b&gt; \\n\" \\\n    \"- Just send a link. Only messages containing just the link will be replaced. \\n\" \\\n    \"- @LinkNinjaBot needs to be added as an admin to work in groups. \\n\\n\" \\\n    \"&lt;b&gt;Settings&lt;/b&gt; \\n\" \\\n    \"Format: /setting {options} \\n\\n\" \\\n    \"/signature {on/off} \\n\" \\\n    \"- &lt;code&gt;/signature on&lt;/code&gt; sends the message with the replaced link, the original link and who it was sent by. \\n\" \\\n    \"- By default it's off in private chats and on in group chats. \\n\\n\" \\\n    \"/domain {your domain/reset} \\n\" \\\n    \"- Choose the domain to replace twitter.com with. \\n\" \\\n    \"- &lt;code&gt;/domain reset&lt;/code&gt; changes it back to fxtwitter.com.\" \\\n\n    bot.reply_to(message, text, parse_mode=\"HTML\")\n\n\n\n\nadmin\n\n admin (message)\n\nsend help message in private chat"
  },
  {
    "objectID": "link_ninja.html#how-to-rundeploy",
    "href": "link_ninja.html#how-to-rundeploy",
    "title": "Link Ninja",
    "section": "How to run/deploy?",
    "text": "How to run/deploy?\nNote: it’ll be easier to create a separate bot for testing and deploying; if you create a webhook for a bot, polling won’t work untill the webhook is deleted\n\nWebhooks\nThis is ideal for deployment since telegram can send updates to our server without us having to keep checking/polling for updates\nTo create a webhook, we’ll have to create a domain and register that with telegram. To do that, open this URL:\nhttps://api.telegram.org/bot&lt;bot_token&gt;/setWebhook?url=&lt;webhook_url&gt;\n\nor optionally with a secret token (like a password):\nhttps://api.telegram.org/bot&lt;bot_token&gt;/setWebhook?url=&lt;webhook_url&gt;&secret_token=&lt;secret_token&gt;\n\nYou can see the status of your webhook with:\nhttps://api.telegram.org/bot&lt;bot_token&gt;/getWebhookInfo\n\nAnd delete your webhooks with:\nhttps://api.telegram.org/bot&lt;bot_token&gt;/deleteWebhook\n\nFor more info on webhooks:\n\nhttps://core.telegram.org/bots/api#setwebhook\nhttps://xabaras.medium.com/setting-your-telegram-bot-webhook-the-easy-way-c7577b2d6f72\n\nWe’ll be deploying with Deta becase it’s both free and convenient 😃\nNote that they require the file to be named main.py\nTo make things easier, we’ll use the webhook functions from our bot library\nCreate a domain on Deta.sh and save that as an environment variable called DOMAIN. Follow this guide for a detailed walk through:\nhttps://medium.com/@noufal.slm/create-your-own-telegram-bot-with-python-and-deta-sh-ef9aee7b93d5\nAn optional environment variable you can set is WEBHOOK_PASSWORD, which is an added bit of security.\n\n# check if a webhook already exists\nif bot.get_webhook_info().url != f'{os.environ[\"DOMAIN\"]}/{os.environ[\"BOT_TOKEN\"]}':\n\n    nest_asyncio.apply()\n\n    # https://pytba.readthedocs.io/en/latest/sync_version/index.html#telebot.TeleBot.set_webhook\n    bot.run_webhooks(\n        webhook_url=f'{os.environ[\"DOMAIN\"]}/{os.environ[\"BOT_TOKEN\"]}', # https://yourdomain.tld/bot_token\n        secret_token=os.environ[\"WEBHOOK_PASSWORD\"], # remove if you don't want to set one\n        drop_pending_updates=True\n    )\n\n\n\nPolling\nUse this for testing; much easier since it doesn’t require any set up!\nIf you’ve already created a webhook for a bot that you now want to use polling for, re-enable polling with:\nhttps://api.telegram.org/bot&lt;bot_token&gt;/getUpdates\n\n# bot.infinity_polling(\n#     allowed_updates=telebot.util.update_types,\n#     skip_pending=True)"
  }
]